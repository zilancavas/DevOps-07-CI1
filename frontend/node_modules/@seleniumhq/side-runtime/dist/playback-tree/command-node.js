"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandType = exports.CommandNode = exports.getCommandDisplayString = void 0;
const preprocessors_1 = require("../preprocessors");
const commands_1 = require("./commands");
const errors_1 = require("../errors");
const getCommandDisplayString = ({ comment, command, target, value, }) => {
    const paramsString = [command, target, value].filter((p) => p).join(' ');
    const commentString = comment ? `(${comment})` : '';
    return `${paramsString} ${commentString}`;
};
exports.getCommandDisplayString = getCommandDisplayString;
class CommandNode {
    constructor(command, { emitControlFlowChange } = {}) {
        this.command = command;
        this.next = undefined;
        this.left = undefined;
        this.right = undefined;
        this.index = 0;
        this.level = 0;
        this.timesVisited = 0;
        this.emitControlFlowChange = emitControlFlowChange
            ? emitControlFlowChange
            : () => { };
    }
    /* I'm not sure what this does yet, so I'm putting it on a shelf atm
    isExtCommand(executor: CommandNode): boolean {
      return !!(
        typeof executor.isExtCommand === 'function' &&
        executor.isExtCommand(this.command.command)
      )
    }
    */
    isControlFlow() {
        return !!(this.left || this.right);
    }
    isTerminal() {
        return (commands_1.ControlFlowCommandChecks.isTerminal(this.command) ||
            this.command.command === '');
    }
    shouldSkip() {
        return Boolean(this.command.skip || this.command.command.startsWith('//'));
    }
    async execute(commandExecutor, args) {
        if (this._isRetryLimit()) {
            throw new Error('Max retry limit exceeded. To override it, specify a new limit in the value input field.');
        }
        if (this.shouldSkip()) {
            return this._executionResult({ skipped: true });
        }
        await commandExecutor.beforeCommand(this.command);
        const result = await this._executeCommand(commandExecutor, args);
        await commandExecutor.afterCommand(this.command);
        return this._executionResult(result);
    }
    async _executeCommand(commandExecutor, { executorOverride } = {}) {
        if (executorOverride) {
            return await executorOverride(this.command.target, this.command.value);
        }
        else if (this.isControlFlow()) {
            return this._evaluate(commandExecutor);
        }
        else if (this.isTerminal()) {
            return;
        }
        else {
            const { command } = this;
            const { comment, target, value } = command;
            const commandName = command.command;
            const customCommand = commandExecutor.customCommands[commandName];
            const existingCommandName = commandExecutor.name(commandName);
            // @ts-expect-error webdriver is too kludged by here
            if (!customCommand && !commandExecutor[existingCommandName]) {
                throw new Error(`Missing expected command type ${commandName}`);
            }
            const executor = customCommand
                ? () => customCommand.execute(command, commandExecutor)
                : // @ts-expect-error webdriver is too kludged by here
                    () => commandExecutor[existingCommandName](target, value, command);
            const cmdList = [
                'click',
                'check',
                'select',
                'type',
                'sendKeys',
                'uncheck',
            ];
            const ignoreRetry = !cmdList.includes(commandName);
            if (ignoreRetry) {
                try {
                    return await executor();
                }
                catch (e) {
                    const err = e;
                    err.message =
                        err.message +
                            ` during${comment ? ` (${comment})` : ''} ${commandName}:${target}:${value}`;
                    throw err;
                }
            }
            return this.retryCommand(executor, Date.now() + commandExecutor.implicitWait);
        }
    }
    async pauseTimeout(timeout) {
        return new Promise((resolve) => setTimeout(resolve, timeout));
    }
    retryCommand(execute, timeout) {
        return new Promise((res, rej) => {
            const timeLimit = timeout - Date.now();
            const commandString = `during${this.command.comment ? ` (${this.command.comment})` : ''} ${this.command.command}:${this.command.target}:${this.command.value}`;
            if (timeLimit <= 0) {
                return rej(new Error(`Operation timed out ${commandString}`));
            }
            const expirationTimer = setTimeout(() => {
                rej(new Error(`Operation timed out ${commandString}`));
            }, timeLimit);
            execute()
                .then((result) => {
                clearTimeout(expirationTimer);
                res(result);
            })
                .catch((e) => {
                clearTimeout(expirationTimer);
                try {
                    this.handleTransientError(e, timeout);
                    setTimeout(() => this.retryCommand(execute, timeout).then(res).catch(rej));
                }
                catch (e) {
                    const err = e;
                    err.message = err.message + ` ${commandString}`;
                    rej(err);
                }
            });
        });
    }
    _executionResult(result = {}) {
        this._incrementTimesVisited();
        return {
            next: this.isControlFlow() ? result.next : this.next,
            skipped: result.skipped,
        };
    }
    handleTransientError(e, timeout) {
        if (e instanceof errors_1.VerificationError) {
            throw e;
        }
        if (e instanceof errors_1.AssertionError) {
            throw e;
        }
        const { command, target, value } = this.command;
        const thisCommand = `${command}-${target}-${value}`;
        const thisErrorMessage = e instanceof Error ? e.message : '';
        const thisTransientError = `${thisCommand}-${thisErrorMessage}`;
        const lastTransientError = this.transientError;
        const isNewErrorMessage = lastTransientError !== thisTransientError;
        const notRetrying = Date.now() > timeout;
        if (isNewErrorMessage) {
            this.transientError = thisTransientError;
            console.warn('Unexpected error occured during command:', thisCommand, notRetrying ? '' : 'retrying...');
            if (thisErrorMessage) {
                console.error(thisErrorMessage);
            }
        }
        if (notRetrying) {
            console.error('Command failure:', thisCommand);
            throw e;
        }
    }
    evaluateForEach(variables) {
        let collection = variables.get((0, preprocessors_1.interpolateScript)(this.command.target, variables).script);
        if (!collection)
            return 'Invalid variable provided.';
        variables.set((0, preprocessors_1.interpolateScript)(this.command.value, variables).script, collection[this.timesVisited]);
        const result = this.timesVisited < collection.length;
        if (result)
            this.emitControlFlowChange({
                commandId: this.command.id,
                type: exports.CommandType.LOOP,
                index: this.timesVisited,
                iterator: collection[this.timesVisited],
                collection,
            });
        // Reset timesVisited if loop ends, needed to support forEach recursion.
        // It's set to -1 since the incrementer will pick it up. Setting it to
        // 0 when called on a subsequent interation.
        else
            this.timesVisited = -1;
        return result;
    }
    _evaluate(commandExecutor) {
        if (commands_1.ControlFlowCommandChecks.isTimes(this.command)) {
            const number = Math.floor(+(0, preprocessors_1.interpolateString)(`${this.command.target}`, commandExecutor.variables));
            if (isNaN(number)) {
                return Promise.reject(new Error('Invalid number provided as a target.'));
            }
            return this._evaluationResult({ value: this.timesVisited < number });
        }
        let expression = (0, preprocessors_1.interpolateScript)(this.command.target, commandExecutor.variables);
        if (commands_1.ControlFlowCommandChecks.isForEach(this.command)) {
            const result = this.evaluateForEach(commandExecutor.variables);
            if (!result) {
                this.emitControlFlowChange({
                    commandId: this.command.id,
                    type: exports.CommandType.LOOP,
                    end: true,
                });
            }
            return this._evaluationResult({
                value: Boolean(result),
            });
        }
        return commandExecutor.evaluateConditional(expression).then((result) => {
            return this._evaluationResult(result);
        });
    }
    _evaluationResult(result) {
        if (result.value) {
            return {
                next: this.right,
            };
        }
        else {
            return {
                next: this.left,
            };
        }
    }
    _incrementTimesVisited() {
        if (commands_1.ControlFlowCommandChecks.isLoop(this.command))
            this.timesVisited++;
    }
    _isRetryLimit() {
        if (commands_1.ControlFlowCommandChecks.isLoop(this.command)) {
            let limit = 1000;
            let value = Math.floor(+this.command.value);
            if (this.command.value && !isNaN(value)) {
                limit = value;
            }
            return this.timesVisited >= limit;
        }
        return false;
    }
}
exports.CommandNode = CommandNode;
exports.CommandType = {
    LOOP: 'loop',
    CONDITIONAL: 'conditional',
};
//# sourceMappingURL=command-node.js.map