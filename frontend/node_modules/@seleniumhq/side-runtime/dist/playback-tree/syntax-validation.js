"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.repeatIfError = exports.validateControlFlowSyntax = void 0;
const commands_1 = require("./commands");
const state_1 = require("./state");
const control_flow_syntax_error_1 = require("./control-flow-syntax-error");
function validateControlFlowSyntax(commandStack) {
    let state = new state_1.State();
    commandStack.forEach(function (command, commandIndex) {
        validateCommand(command, commandIndex, state);
    });
    if (!state.empty()) {
        throw new control_flow_syntax_error_1.ControlFlowSyntaxError('Incomplete block at ' + state.top().command, state.top().index);
    }
    else {
        return true;
    }
}
exports.validateControlFlowSyntax = validateControlFlowSyntax;
function validateCommand(command, commandIndex, state) {
    if (!command.skip && command.command in commandValidators) {
        const validatorKey = command.command;
        return commandValidators[validatorKey](command.command, commandIndex, state);
    }
}
const commandValidators = {
    [commands_1.ControlFlowCommandNames.do]: trackControlFlowBranchOpen,
    [commands_1.ControlFlowCommandNames.else]: validateElse,
    [commands_1.ControlFlowCommandNames.elseIf]: validateElseIf,
    [commands_1.ControlFlowCommandNames.end]: validateEnd,
    [commands_1.ControlFlowCommandNames.forEach]: trackControlFlowBranchOpen,
    [commands_1.ControlFlowCommandNames.if]: trackControlFlowBranchOpen,
    [commands_1.ControlFlowCommandNames.repeatIf]: validateRepeatIf,
    [commands_1.ControlFlowCommandNames.times]: trackControlFlowBranchOpen,
    [commands_1.ControlFlowCommandNames.try]: trackControlFlowBranchOpen,
    [commands_1.ControlFlowCommandNames.while]: trackControlFlowBranchOpen,
};
function trackControlFlowBranchOpen(commandName, commandIndex, state) {
    state.push({ command: commandName, index: commandIndex });
}
function validateElse(commandName, commandIndex, state) {
    if (!commands_1.ControlFlowCommandChecks.isIfBlock(state.top())) {
        throw new control_flow_syntax_error_1.ControlFlowSyntaxError('An else used outside of an if block', commandIndex);
    }
    if (commands_1.ControlFlowCommandChecks.isElse(state.top())) {
        throw new control_flow_syntax_error_1.ControlFlowSyntaxError('Too many else commands used', commandIndex);
    }
    state.push({ command: commandName, index: commandIndex });
}
function validateElseIf(commandName, commandIndex, state) {
    if (!commands_1.ControlFlowCommandChecks.isIfBlock(state.top())) {
        throw new control_flow_syntax_error_1.ControlFlowSyntaxError('An else if used outside of an if block', commandIndex);
    }
    if (commands_1.ControlFlowCommandChecks.isElse(state.top())) {
        throw new control_flow_syntax_error_1.ControlFlowSyntaxError('Incorrect command order of else if / else', commandIndex);
    }
    state.push({ command: commandName, index: commandIndex });
}
function validateEnd(commandName, commandIndex, state) {
    if (commands_1.ControlFlowCommandChecks.isBlockOpen(state.top())) {
        state.pop();
    }
    else if (commands_1.ControlFlowCommandChecks.isElseOrElseIf(state.top())) {
        state.pop();
        validateEnd(commandName, commandIndex, state);
    }
    else {
        throw new control_flow_syntax_error_1.ControlFlowSyntaxError('Use of end without an opening keyword', commandIndex);
    }
}
function validateRepeatIf(_commandName, commandIndex, state) {
    if (!commands_1.ControlFlowCommandChecks.isDo(state.top())) {
        repeatIfError(commandIndex);
    }
    state.pop();
}
function repeatIfError(commandIndex) {
    throw new control_flow_syntax_error_1.ControlFlowSyntaxError('A repeat if used without a do block', commandIndex);
}
exports.repeatIfError = repeatIfError;
//# sourceMappingURL=syntax-validation.js.map