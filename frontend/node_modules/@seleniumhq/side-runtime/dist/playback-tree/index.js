"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCommandNodesFromCommandStack = exports.createPlaybackTree = void 0;
const command_node_1 = require("./command-node");
const state_1 = require("./state");
const syntax_validation_1 = require("./syntax-validation");
const command_leveler_1 = require("./command-leveler");
const commands_1 = require("./commands");
function createPlaybackTree(commandStack, { isValidationDisabled, emitControlFlowChange } = {}) {
    let nodes = createCommandNodesFromCommandStack(commandStack, isValidationDisabled, emitControlFlowChange);
    return {
        startingCommandNode: nodes[0],
        nodes,
        containsControlFlow: containsControlFlow(nodes),
    };
}
exports.createPlaybackTree = createPlaybackTree;
function containsControlFlow(nodes) {
    return !!nodes.filter((node) => node.isControlFlow()).length;
}
function createCommandNodesFromCommandStack(commandStack, isValidationDisabled = false, emitControlFlowChange) {
    if (!isValidationDisabled)
        (0, syntax_validation_1.validateControlFlowSyntax)(commandStack);
    let levels = (0, command_leveler_1.deriveCommandLevels)(commandStack);
    let nodes = createCommandNodes(commandStack, levels, emitControlFlowChange);
    return connectCommandNodes(nodes);
}
exports.createCommandNodesFromCommandStack = createCommandNodesFromCommandStack;
function createCommandNodes(commandStack, levels, emitControlFlowChange) {
    let commandNodes = [];
    commandStack.forEach(function (command, index) {
        let node = new command_node_1.CommandNode(command, { emitControlFlowChange });
        node.index = index;
        node.level = levels[index];
        commandNodes.push(node);
    });
    return commandNodes;
}
function connectCommandNodes(_commandNodeStack) {
    let commandNodeStack = [..._commandNodeStack];
    let state = new state_1.State();
    commandNodeStack.forEach(function (commandNode) {
        let nextCommandNode = commandNodeStack[commandNode.index + 1];
        connectCommandNode({
            commandNode,
            nextCommandNode,
            commandNodeStack,
            state,
        });
    });
    return commandNodeStack;
}
const connectDefault = (commandNode, _nextCommandNode, stack, state) => {
    let nextCommandNode;
    if (commands_1.ControlFlowCommandChecks.isIf(state.top()) &&
        commands_1.ControlFlowCommandChecks.isElseOrElseIf(_nextCommandNode.command)) {
        nextCommandNode = findNextNodeBy(stack, commandNode.index, state.top().level, commands_1.ControlFlowCommandNames.end);
    }
    else if (commands_1.ControlFlowCommandChecks.isLoop(state.top()) &&
        commands_1.ControlFlowCommandChecks.isEnd(_nextCommandNode.command)) {
        nextCommandNode = stack[state.top().index];
    }
    else {
        nextCommandNode = _nextCommandNode;
    }
    connectNext(commandNode, nextCommandNode);
};
const trackBranchOpen = (commandNode, nextCommandNode, _stack, state) => {
    state.push({
        command: commandNode.command.command,
        level: commandNode.level,
        index: commandNode.index,
    });
    if (commands_1.ControlFlowCommandChecks.isDo(commandNode.command))
        connectNext(commandNode, nextCommandNode);
};
const trackBranchClose = (commandNode, nextCommandNode, stack, state) => {
    state.pop();
    const top = state.top();
    let nextCommandNodeOverride;
    if (top &&
        commands_1.ControlFlowCommandChecks.isLoop(top) &&
        nextCommandNode &&
        commands_1.ControlFlowCommandChecks.isEnd(nextCommandNode.command))
        nextCommandNodeOverride = stack[top.index];
    connectNext(commandNode, nextCommandNodeOverride ? nextCommandNodeOverride : nextCommandNode);
};
const connectConditionalForBranchOpen = (commandNode, nextCommandNode, stack, state) => {
    trackBranchOpen(commandNode, nextCommandNode, stack, state);
    connectConditional(commandNode, nextCommandNode, stack);
};
const connectConditional = (commandNode, nextCommandNode, stack) => {
    let left = findNextNodeBy(stack, commandNode.index, commandNode.level);
    let right = nextCommandNode;
    commandNode.right = right;
    commandNode.left = left;
};
function connectNext(commandNode, nextCommandNode) {
    commandNode.next = nextCommandNode;
}
const connectDo = (commandNode, nextCommandNode, stack, state) => {
    const top = state.top();
    if (!top)
        (0, syntax_validation_1.repeatIfError)();
    commandNode.right = stack[top.index];
    commandNode.left = nextCommandNode;
    state.pop();
};
function findNextNodeBy(stack, index, level, commandName) {
    for (let i = index + 1; i < stack.length + 1; i++) {
        if (commandName) {
            if (stack[i].level === level &&
                stack[i].command.command === commandName) {
                return stack[i];
            }
        }
        else {
            if (stack[i].level === level) {
                return stack[i];
            }
        }
    }
    return undefined;
}
function connectCommandNode({ commandNode, nextCommandNode, commandNodeStack, state, }) {
    if (commandNode.command.skip ||
        !(commandNode.command.command in commandNodeConnectors)) {
        connectDefault(commandNode, nextCommandNode, commandNodeStack, state);
    }
    else {
        const connectorKey = commandNode.command
            .command;
        commandNodeConnectors[connectorKey](commandNode, nextCommandNode, commandNodeStack, state);
    }
}
const commandNodeConnectors = {
    [commands_1.ControlFlowCommandNames.do]: trackBranchOpen,
    [commands_1.ControlFlowCommandNames.else]: connectNext,
    [commands_1.ControlFlowCommandNames.elseIf]: connectConditional,
    [commands_1.ControlFlowCommandNames.end]: trackBranchClose,
    [commands_1.ControlFlowCommandNames.forEach]: connectConditionalForBranchOpen,
    [commands_1.ControlFlowCommandNames.if]: connectConditionalForBranchOpen,
    [commands_1.ControlFlowCommandNames.repeatIf]: connectDo,
    [commands_1.ControlFlowCommandNames.times]: connectConditionalForBranchOpen,
    [commands_1.ControlFlowCommandNames.try]: connectConditionalForBranchOpen,
    [commands_1.ControlFlowCommandNames.while]: connectConditionalForBranchOpen,
};
//# sourceMappingURL=index.js.map