"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveCommandLevels = void 0;
const commands_1 = require("./commands");
function deriveCommandLevels(commandStack) {
    let level = 0;
    let levels = [];
    commandStack.forEach(function (command) {
        const result = levelCommand(command, level, levels);
        level = result.level;
        levels = result.levels;
    });
    return levels;
}
exports.deriveCommandLevels = deriveCommandLevels;
const levelDefault = (_command, level, _levels) => {
    let levels = [..._levels];
    levels.push(level);
    return { level, levels };
};
const levelBranchOpen = (_command, level, _levels) => {
    let levels = [..._levels];
    levels.push(level);
    level++;
    return { level, levels };
};
const levelBranchEnd = (_command, level, _levels) => {
    let levels = [..._levels];
    level--;
    levels.push(level);
    return { level, levels };
};
const levelElse = (_command, level, _levels) => {
    let levels = [..._levels];
    level--;
    levels.push(level);
    level++;
    return { level, levels };
};
const levelCommand = (command, level, levels) => {
    if (!command.skip && command.command in commandLevelers) {
        const levelerKey = command.command;
        return commandLevelers[levelerKey](command, level, levels);
    }
    return levelDefault(command, level, levels);
};
const commandLevelers = {
    [commands_1.ControlFlowCommandNames.do]: levelBranchOpen,
    [commands_1.ControlFlowCommandNames.else]: levelElse,
    [commands_1.ControlFlowCommandNames.elseIf]: levelElse,
    [commands_1.ControlFlowCommandNames.end]: levelBranchEnd,
    [commands_1.ControlFlowCommandNames.forEach]: levelBranchOpen,
    [commands_1.ControlFlowCommandNames.if]: levelBranchOpen,
    [commands_1.ControlFlowCommandNames.repeatIf]: levelBranchEnd,
    [commands_1.ControlFlowCommandNames.times]: levelBranchOpen,
    [commands_1.ControlFlowCommandNames.try]: levelBranchOpen,
    [commands_1.ControlFlowCommandNames.while]: levelBranchOpen,
};
//# sourceMappingURL=command-leveler.js.map