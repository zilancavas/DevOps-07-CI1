"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const preprocessors_1 = require("../preprocessors");
const variables_1 = __importDefault(require("../variables"));
const FakeExecutor_1 = __importDefault(require("./util/FakeExecutor"));
let variables;
beforeEach(() => {
    variables = new variables_1.default();
});
describe('preprocessor composition', () => {
    it('should do nothing if the command takes no arguments', () => {
        const fn = jest.fn();
        const f = (0, preprocessors_1.composePreprocessors)(fn);
        f();
        expect(fn).toHaveBeenCalledWith();
    });
    it('should compose target preprocessor', () => {
        variables.set('a', 'a');
        const fn = jest.fn();
        FakeExecutor_1.default.prototype.doFake = (0, preprocessors_1.composePreprocessors)(preprocessors_1.interpolateString, fn);
        const exec = new FakeExecutor_1.default();
        exec.init({ variables });
        exec.doFake('${a}');
        expect(fn).toHaveBeenCalledWith('a');
    });
    it('should compose value preprocessor', () => {
        variables.set('a', 'a');
        const fn = jest.fn();
        FakeExecutor_1.default.prototype.doFake = (0, preprocessors_1.composePreprocessors)(preprocessors_1.interpolateString, preprocessors_1.interpolateString, fn);
        const exec = new FakeExecutor_1.default();
        exec.init({ variables });
        exec.doFake('${a}', '${a}');
        expect(fn).toHaveBeenCalledWith('a', 'a');
    });
    it('should compose targets preprocessor', () => {
        variables.set('a', 'a');
        const fn = jest.fn();
        FakeExecutor_1.default.prototype.doFake = (0, preprocessors_1.composePreprocessors)(preprocessors_1.interpolateString, preprocessors_1.interpolateString, { targets: (0, preprocessors_1.preprocessArray)(preprocessors_1.interpolateString) }, fn);
        const exec = new FakeExecutor_1.default();
        exec.init({ variables });
        exec.doFake('${a}', '${a}', {
            targets: [
                ['${a}', 's'],
                ['${a}', 's'],
            ],
        });
        expect(fn).toHaveBeenCalledWith('a', 'a', {
            targets: [
                ['a', 's'],
                ['a', 's'],
            ],
        });
    });
    it('should ignore preprocess if null is passed', () => {
        variables.set('a', 'a');
        const fn = jest.fn();
        FakeExecutor_1.default.prototype.doFake = (0, preprocessors_1.composePreprocessors)(preprocessors_1.interpolateString, null, fn);
        const exec = new FakeExecutor_1.default();
        exec.init({ variables });
        exec.doFake('${a}', '${a}');
        expect(fn).toHaveBeenCalledWith('a', '${a}');
    });
    it('should skip targets preprocessing if it is undefined', () => {
        variables.set('a', 'a');
        const fn = jest.fn();
        FakeExecutor_1.default.prototype.doFake = (0, preprocessors_1.composePreprocessors)(preprocessors_1.interpolateString, preprocessors_1.interpolateString, (0, preprocessors_1.preprocessArray)(preprocessors_1.interpolateString), fn);
        const exec = new FakeExecutor_1.default();
        exec.init({ variables });
        exec.doFake('${a}', '${a}');
        expect(fn).toHaveBeenCalledWith('a', 'a');
    });
});
describe('array preprocessing', () => {
    it('should preprocess array of string using a single interpolator', () => {
        variables.set('a', 'a');
        const arr = [
            ['${a}a', 's'],
            ['${a}b', 's'],
        ];
        expect((0, preprocessors_1.preprocessArray)(preprocessors_1.interpolateString)(arr, variables)).toEqual([
            ['aa', 's'],
            ['ab', 's'],
        ]);
    });
});
describe('interpolate string', () => {
    it('should interpolate false values', () => {
        variables.set('a', undefined);
        expect((0, preprocessors_1.interpolateString)('${a}', variables)).toBe('undefined');
        variables.set('a', null);
        expect((0, preprocessors_1.interpolateString)('${a}', variables)).toBe('null');
        variables.set('a', false);
        expect((0, preprocessors_1.interpolateString)('${a}', variables)).toBe('false');
        variables.set('a', 0);
        expect((0, preprocessors_1.interpolateString)('${a}', variables)).toBe('0');
        variables.set('a', '');
        expect((0, preprocessors_1.interpolateString)('${a}', variables)).toBe('');
    });
});
describe('interpolate script', () => {
    it('should not interpolate a script without variables', () => {
        const script = 'return 1';
        expect((0, preprocessors_1.interpolateScript)(script, variables).script).toEqual(script);
    });
    it('should interpolate a script with a single argument', () => {
        variables.set('a', 1);
        const script = 'return ${a}';
        const r = (0, preprocessors_1.interpolateScript)(script, variables);
        expect(r.script).toEqual('return arguments[0]');
        expect(r.argv[0]).toBe(1);
    });
    it('should interpolate a script with multiple arguments', () => {
        variables.set('a', 1);
        variables.set('b', false);
        const script = 'return ${a} + ${a} || ${b}';
        const r = (0, preprocessors_1.interpolateScript)(script, variables);
        expect(r.script).toEqual('return arguments[0] + arguments[0] || arguments[1]');
        expect(r.argv[0]).toBe(1);
        expect(r.argv[1]).toBe(false);
    });
});
//# sourceMappingURL=preprocessors.spec.js.map