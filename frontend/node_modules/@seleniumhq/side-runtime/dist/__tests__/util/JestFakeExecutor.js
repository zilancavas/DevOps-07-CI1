"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const variables_1 = __importDefault(require("../../variables"));
class FakeExecutor {
    constructor(..._args) {
        this.customCommands = {};
        this.implicitWait = 50;
        this.initialized = false;
        this.killed = false;
        this.variables = new variables_1.default();
        this.init = jest.fn(({ variables }) => {
            // this can be async
            this.variables = variables;
            this.initialized = true;
        });
        this.executeHook = jest.fn();
        this.name = jest.fn((command) => {
            if (!command) {
                return 'skip';
            }
            const upperCase = command.charAt(0).toUpperCase() + command.slice(1);
            const func = 'do' + upperCase;
            // @ts-expect-error idk what to do here
            if (!this[func]) {
                throw new Error(`Unknown command ${command}`);
            }
            return func;
        });
        this.cancel = jest.fn();
        this.cleanup = jest.fn();
        this.kill = jest.fn(async () => {
            this.killed = true;
        });
        this.beforeCommand = jest.fn(async (_commandObject) => {
            if (!this.initialized)
                throw new Error('executor is dead');
            if (this.killed)
                throw new Error('playback is dead');
        });
        this.afterCommand = jest.fn((_commandObject) => {
            if (!this.initialized)
                throw new Error('executor is dead');
            if (this.killed)
                throw new Error('playback is dead');
        });
        this.doAssert = jest.fn();
        this.doAssertText = jest.fn();
        this.doPause = jest.fn((timeout = 0) => new Promise((res) => {
            setTimeout(res, Number(timeout));
        }));
        this.doOpen = jest.fn();
        this.doVerify = jest.fn();
        this.doVerifyText = jest.fn();
        this.doFake = jest.fn();
        this.evaluateConditional = jest.fn();
        return this;
    }
}
exports.default = FakeExecutor;
//# sourceMappingURL=JestFakeExecutor.js.map