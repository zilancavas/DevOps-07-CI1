"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commands_1 = require("../../playback-tree/commands");
const command_node_1 = require("../../playback-tree/command-node");
const variables_1 = __importDefault(require("../../variables"));
const FakeExecutor_1 = __importDefault(require("../util/FakeExecutor"));
describe('Command Node', () => {
    let variables;
    beforeEach(() => {
        variables = new variables_1.default();
    });
    it('control flow check returns correct result', () => {
        let node = new command_node_1.CommandNode(undefined);
        // @ts-expect-error
        node.right = 'asdf';
        expect(node.isControlFlow()).toBeTruthy();
        node.left = undefined;
        // @ts-expect-error
        node.right = 'asdf';
        expect(node.isControlFlow()).toBeTruthy();
    });
    it('retry limit defaults to 1000', () => {
        const command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.times,
            target: '',
            value: '',
        };
        const node = new command_node_1.CommandNode(command);
        node.timesVisited = 999;
        expect(node._isRetryLimit()).toBeFalsy();
        node.timesVisited = 1000;
        expect(node._isRetryLimit()).toBeTruthy();
    });
    it('retry limit can be overriden', () => {
        const command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.repeatIf,
            target: '',
            value: '5',
        };
        const node = new command_node_1.CommandNode(command);
        node.timesVisited = 5;
        expect(node._isRetryLimit()).toBeTruthy();
    });
    it('forEach fetches count from preset variable', () => {
        const collectionName = 'blah';
        variables.set(collectionName, [
            { a: 'a1', b: 'b1' },
            { a: 'a2', b: 'b2' },
        ]);
        const command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.forEach,
            target: collectionName,
            value: 'iteratorVar',
        };
        const node = new command_node_1.CommandNode(command);
        expect(node.evaluateForEach(variables)).toEqual(true);
    });
    it('forEach errors without a valid variable', () => {
        const command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.forEach,
            target: 'asdf',
            value: '',
        };
        const node = new command_node_1.CommandNode(command);
        const result = node.evaluateForEach(variables);
        expect(result).toEqual('Invalid variable provided.');
    });
    it('forEach stores iterated collection entry on a variable using the provided name', () => {
        const collectionName = 'asdf';
        variables.set(collectionName, [
            { a: 'a1', b: 'b1' },
            { a: 'a2', b: 'b2' },
        ]);
        const command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.forEach,
            target: collectionName,
            value: 'iteratorVar',
        };
        const node = new command_node_1.CommandNode(command);
        node.evaluateForEach(variables);
        expect(variables.get('iteratorVar')).toEqual({ a: 'a1', b: 'b1' });
    });
    it('forEach resets timesVisited after completing', () => {
        const collection = { name: 'asdf', value: [{ a: 'a' }, { b: 'b' }] };
        variables.set(collection.name, collection.value);
        const node = new command_node_1.CommandNode({
            id: 'a',
            command: commands_1.ControlFlowCommandNames.forEach,
            target: collection.name,
            value: 'iteratorVar',
        });
        node.timesVisited = collection.value.length + 1;
        node.evaluateForEach(variables);
        expect(node.timesVisited).toEqual(-1);
    });
    it('execute resolves with an error message when too many retries attempted in a loop', () => {
        const command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.while,
            target: '',
            value: '2',
        };
        const executor = new FakeExecutor_1.default();
        const node = new command_node_1.CommandNode(command);
        node.timesVisited = 3;
        return node.execute(executor).catch((err) => {
            expect(err.message).toEqual('Max retry limit exceeded. To override it, specify a new limit in the value input field.');
        });
    });
    it("evaluate resolves with an error message on 'times' when an invalid number is provided", async () => {
        const command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.times,
            target: 'asdf',
            value: '',
        };
        const executor = new FakeExecutor_1.default();
        executor.init({ variables: new variables_1.default() });
        const node = new command_node_1.CommandNode(command);
        try {
            await node._evaluate(executor);
        }
        catch (err) {
            expect(err.message).toEqual('Invalid number provided as a target.');
        }
    });
    it('timesVisited only increments for control flow commands', () => {
        let command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.times,
            target: '',
            value: '',
        };
        let node = new command_node_1.CommandNode(command);
        expect(node.timesVisited).toBe(0);
        node._incrementTimesVisited();
        expect(node.timesVisited).toBe(1);
        const nextCommand = {
            id: 'a',
            command: 'command',
            target: '',
            value: '',
        };
        node = new command_node_1.CommandNode(nextCommand);
        expect(node.timesVisited).toBe(0);
        node._incrementTimesVisited();
        expect(node.timesVisited).toBe(0);
    });
    it("evaluationResult returns the 'right' node on true", () => {
        const command = {
            id: 'a',
            command: 'a',
            target: '',
            value: '',
        };
        const node = new command_node_1.CommandNode(command);
        // @ts-expect-error
        node.right = 'b';
        // @ts-expect-error
        node.left = 'c';
        const result = node._evaluationResult({ value: true });
        expect(result.next).toEqual('b');
    });
    it("evaluationResult returns the 'left' node on false", () => {
        const command = {
            id: 'a',
            command: 'a',
            target: '',
            value: '',
        };
        const node = new command_node_1.CommandNode(command);
        // @ts-expect-error
        node.right = 'b';
        // @ts-expect-error
        node.left = 'c';
        const result = node._evaluationResult({ value: false });
        expect(result.next).toEqual('c');
    });
    it("executionResult returns the 'next' node on non-controlflow commands", () => {
        const command = {
            id: 'a',
            command: 'open',
            target: '',
            value: '',
        };
        let nodeA = new command_node_1.CommandNode(command);
        const nodeB = new command_node_1.CommandNode(command);
        nodeA.next = nodeB;
        expect(nodeA._executionResult().next).toEqual(nodeB);
    });
    it("executionResult returns a 'next' node on control flow", () => {
        const command = {
            id: 'a',
            command: commands_1.ControlFlowCommandNames.if,
            target: '',
            value: '',
        };
        let nodeA = new command_node_1.CommandNode(command);
        // @ts-expect-error
        nodeA.left = 'asdf';
        const nodeB = new command_node_1.CommandNode(command);
        const result = {
            next: nodeB,
        };
        expect(nodeA._executionResult(result).next).toEqual(nodeB);
    });
});
//# sourceMappingURL=command-node.spec.js.map