"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
Object.defineProperty(exports, "__esModule", { value: true });
const syntax_validation_1 = require("../../playback-tree/syntax-validation");
const commands_1 = require("../../playback-tree/commands");
function createCommand(command) {
    return {
        id: 'a',
        command,
        target: '',
        value: '',
    };
}
describe('Control Flow', () => {
    describe('Preprocess', () => {
        describe('Syntax Validation', () => {
            test('if, end', () => {
                let result = (0, syntax_validation_1.validateControlFlowSyntax)([
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ]);
                expect(result).toBeTruthy();
            });
            test('if, else, end', () => {
                let result = (0, syntax_validation_1.validateControlFlowSyntax)([
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.else),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ]);
                expect(result).toBeTruthy();
            });
            test('if, elseIf, end', () => {
                let result = (0, syntax_validation_1.validateControlFlowSyntax)([
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.elseIf),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ]);
                expect(result).toBeTruthy();
            });
            test('if, elseIf, else, end', () => {
                let result = (0, syntax_validation_1.validateControlFlowSyntax)([
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.elseIf),
                    createCommand(commands_1.ControlFlowCommandNames.else),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ]);
                expect(result).toBeTruthy();
            });
            test('while, end', () => {
                let result = (0, syntax_validation_1.validateControlFlowSyntax)([
                    createCommand(commands_1.ControlFlowCommandNames.while),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ]);
                expect(result).toBeTruthy();
            });
            test('times, end', () => {
                let result = (0, syntax_validation_1.validateControlFlowSyntax)([
                    createCommand('times'),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ]);
                expect(result).toBeTruthy();
            });
            test('do, repeatIf', () => {
                let result = (0, syntax_validation_1.validateControlFlowSyntax)([
                    createCommand(commands_1.ControlFlowCommandNames.do),
                    createCommand(commands_1.ControlFlowCommandNames.repeatIf),
                ]);
                expect(result).toBeTruthy();
            });
            test('do, while, end, repeatIf', () => {
                let result = (0, syntax_validation_1.validateControlFlowSyntax)([
                    createCommand(commands_1.ControlFlowCommandNames.do),
                    createCommand(commands_1.ControlFlowCommandNames.while),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                    createCommand(commands_1.ControlFlowCommandNames.repeatIf),
                ]);
                expect(result).toBeTruthy();
            });
        });
        describe('Syntax Invalidation', () => {
            test('if', () => {
                let input = [createCommand(commands_1.ControlFlowCommandNames.if)];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Incomplete block at if');
            });
            test('if, if, end', () => {
                let input = [
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Incomplete block at if');
            });
            test('if, else, elseIf, end', () => {
                let input = [
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.else),
                    createCommand(commands_1.ControlFlowCommandNames.elseIf),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Incorrect command order of else if / else');
            });
            test('if, else, else, end', () => {
                let input = [
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.else),
                    createCommand(commands_1.ControlFlowCommandNames.else),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Too many else commands used');
            });
            test('else', () => {
                let input = [createCommand(commands_1.ControlFlowCommandNames.else)];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('An else used outside of an if block');
            });
            test('else, else', () => {
                let input = [
                    createCommand(commands_1.ControlFlowCommandNames.else),
                    createCommand(commands_1.ControlFlowCommandNames.else),
                ];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('An else used outside of an if block');
            });
            test('elseIf', () => {
                let input = [createCommand(commands_1.ControlFlowCommandNames.elseIf)];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('An else if used outside of an if block');
            });
            test('while', () => {
                let input = [createCommand(commands_1.ControlFlowCommandNames.while)];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Incomplete block at while');
            });
            test('if, while', () => {
                let input = [
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.while),
                ];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Incomplete block at while');
            });
            test('if, while, end', () => {
                let input = [
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.while),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Incomplete block at if');
            });
            test('if, while, else, end', () => {
                let input = [
                    createCommand(commands_1.ControlFlowCommandNames.if),
                    createCommand(commands_1.ControlFlowCommandNames.while),
                    createCommand(commands_1.ControlFlowCommandNames.else),
                    createCommand(commands_1.ControlFlowCommandNames.end),
                ];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('An else used outside of an if block');
            });
            test('times', () => {
                let input = [createCommand('times')];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Incomplete block at times');
            });
            test('forEach', () => {
                let input = [createCommand(commands_1.ControlFlowCommandNames.forEach)];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow(`Incomplete block at ${commands_1.ControlFlowCommandNames.forEach}`);
            });
            test('repeatIf', () => {
                let input = [createCommand(commands_1.ControlFlowCommandNames.repeatIf)];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('A repeat if used without a do block');
            });
            test('do', () => {
                let input = [createCommand(commands_1.ControlFlowCommandNames.do)];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Incomplete block at do');
            });
            test('end', () => {
                let input = [createCommand(commands_1.ControlFlowCommandNames.end)];
                expect(function () {
                    (0, syntax_validation_1.validateControlFlowSyntax)(input);
                }).toThrow('Use of end without an opening keyword');
            });
        });
    });
});
//# sourceMappingURL=syntax-validation.spec.js.map