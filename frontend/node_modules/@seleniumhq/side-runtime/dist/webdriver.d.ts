import webdriver, { Capabilities, WebDriver, WebElement as WebElementShape } from 'selenium-webdriver';
import Variables from './variables';
import { Fn } from '@seleniumhq/side-commons';
import { CommandShape } from '@seleniumhq/side-model';
import { PluginRuntimeShape, StoreWindowHandleHookInput, WindowAppearedHookInput, WindowSwitchedHookInput } from './types';
export type ExpandedCapabilities = Partial<Capabilities> & {
    browserName: string;
    'goog:chromeOptions'?: Record<string, boolean | number | string | string[]>;
};
declare const state: unique symbol;
/**
 * This is a polyfill type to allow for unsupported electron
 * driver methods to override with their own custom implementations
 */
export interface WindowAPI {
    setWindowSize: (executor: WebDriverExecutor, width: number, height: number) => Promise<void>;
}
export interface WebDriverExecutorConstructorArgs {
    capabilities?: ExpandedCapabilities;
    customCommands?: PluginRuntimeShape['commands'];
    disableCodeExportCompat?: boolean;
    driver?: WebDriver;
    hooks?: WebDriverExecutorHooks;
    implicitWait?: number;
    server?: string;
}
export interface WebDriverExecutorInitOptions {
    baseUrl: string;
    debug?: boolean;
    logger: Console;
    variables: Variables;
}
export interface WebDriverExecutorCondEvalResult {
    value: boolean;
}
export interface BeforePlayHookInput {
    driver: WebDriverExecutor;
}
export interface CommandHookInput {
    command: CommandShape;
}
export type GeneralHook<T> = (input: T) => Promise<void> | void;
export interface WebDriverExecutorHooks {
    onBeforePlay?: GeneralHook<BeforePlayHookInput>;
    onAfterCommand?: GeneralHook<CommandHookInput>;
    onBeforeCommand?: GeneralHook<CommandHookInput>;
    onStoreWindowHandle?: GeneralHook<StoreWindowHandleHookInput>;
    onWindowAppeared?: GeneralHook<WindowAppearedHookInput>;
    onWindowSwitched?: GeneralHook<WindowSwitchedHookInput>;
}
export type HookKeys = keyof WebDriverExecutorHooks;
export interface ElementEditableScriptResult {
    enabled: boolean;
    readonly: boolean;
}
export interface ScriptShape {
    script: string;
    argv: any[];
}
export default class WebDriverExecutor {
    constructor({ customCommands, disableCodeExportCompat, driver, capabilities, server, hooks, implicitWait, }: WebDriverExecutorConstructorArgs);
    baseUrl?: string;
    variables: Variables;
    cancellable?: {
        cancel: () => void;
    };
    capabilities?: ExpandedCapabilities;
    customCommands: Required<PluginRuntimeShape>['commands'];
    disableCodeExportCompat: boolean;
    driver: WebDriver;
    server?: string;
    windowHandle?: string;
    hooks: WebDriverExecutorHooks;
    implicitWait: number;
    initialized: boolean;
    logger?: Console;
    [state]?: any;
    getDriverSync({ debug, logger, }: Pick<WebDriverExecutorInitOptions, 'debug' | 'logger'>): webdriver.ThenableWebDriver;
    getDriver({ debug, logger, }: Pick<WebDriverExecutorInitOptions, 'debug' | 'logger'>): Promise<webdriver.WebDriver>;
    init({ baseUrl, debug, logger, variables, }: WebDriverExecutorInitOptions): Promise<void>;
    cancel(): Promise<void>;
    cleanup(persistSession?: boolean): Promise<void>;
    isAlive(): boolean;
    name(command: string): string;
    nameTransform(command: string): string;
    executeHook<T extends HookKeys>(hook: T, ...args: Parameters<NonNullable<WebDriverExecutorHooks[T]>>): Promise<void>;
    beforeCommand(commandObject: CommandShape): Promise<void>;
    afterCommand(commandObject: CommandShape): Promise<void>;
    waitForNewWindow(timeout?: number): Promise<string | undefined>;
    registerCommand(commandName: string, fn: Fn): void;
    skip(): Promise<void>;
    doOpen(url: string): Promise<void>;
    doSetWindowSize(widthXheight: string): Promise<void>;
    doSelectWindow(handleLocator: string): Promise<void>;
    doClose(): Promise<void>;
    doSelectFrame(locator: string): Promise<void>;
    doAddSelection(locator: string, optionLocator: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doRemoveSelection(locator: string, optionLocator: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doCheck(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doUncheck(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doClick(locator: string, _?: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doClickAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doDoubleClick(locator: string, _?: string, _commandObject?: Partial<CommandShape>): Promise<void>;
    doDoubleClickAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doDragAndDropToObject(dragLocator: string, dropLocator: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseDown(locator: string, _?: string, _commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseDownAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseMoveAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseOut(locator: string, _?: string, _commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseOver(locator: string, _?: string, _commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseUp(locator: string, _?: string, _commandObject?: Partial<CommandShape>): Promise<void>;
    doMouseUpAt(locator: string, coordString: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doSelect(locator: string, optionLocator: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doSubmit(locator: string, _?: string, _commandObject?: Partial<CommandShape>): Promise<void>;
    doEditContent(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doType(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doSendKeys(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doWaitForElementEditable(locator: string, timeout: string): Promise<void>;
    doWaitForElementNotEditable(locator: string, timeout: string): Promise<void>;
    doWaitForElementPresent(locator: string, timeout: string, commandObj?: Partial<CommandShape>): Promise<void>;
    doWaitForElementNotPresent(locator: string, timeout: string): Promise<void>;
    doWaitForElementVisible(locator: string, timeout: string, commandObj?: Partial<CommandShape>): Promise<void>;
    doWaitForElementNotVisible(locator: string, timeout: string): Promise<void>;
    doWaitForText(locator: string, text: string, commandObj?: Partial<CommandShape>): Promise<void>;
    doRunScript(script: ScriptShape): Promise<void>;
    doExecuteScript(script: ScriptShape, optionalVariable?: string): Promise<void>;
    doExecuteAsyncScript(script: ScriptShape, optionalVariable?: string): Promise<void>;
    doAcceptAlert(): Promise<void>;
    doAcceptConfirmation(): Promise<void>;
    doAnswerPrompt(optAnswer?: string): Promise<void>;
    doDismissConfirmation(): Promise<void>;
    doDismissPrompt(): Promise<void>;
    doStore(string: string, variable: string): Promise<void>;
    doStoreAttribute(attributeLocator: string, variable: string): Promise<void>;
    doStoreElementCount(locator: string, variable: string): Promise<void>;
    doStoreJson(json: string, variable: string): Promise<void>;
    doStoreText(locator: string, variable: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doStoreTitle(variable: string): Promise<void>;
    doStoreValue(locator: string, variable: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doStoreWindowHandle(variable: string): Promise<void>;
    doAssert(variableName: string, value: string): Promise<void>;
    doAssertAlert(expectedText: string): Promise<void>;
    doAssertConfirmation(expectedText: string): Promise<void>;
    doAssertEditable(locator: string, _?: string, _commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotEditable(locator: string, _?: string, _commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertPrompt(expectedText: string): Promise<void>;
    doAssertTitle(title: string): Promise<void>;
    doAssertElementPresent(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertElementNotPresent(locator: string): Promise<void>;
    doAssertText(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotText(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertValue(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotValue(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertChecked(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotChecked(locator: string, _: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertSelectedValue(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotSelectedValue(locator: string, value: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertSelectedLabel(locator: string, label: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doAssertNotSelectedLabel(locator: string, label: string, commandObject?: Partial<CommandShape>): Promise<void>;
    doDebugger(): Promise<void>;
    doEcho(string: string): Promise<void>;
    doPause(time: number): Promise<void>;
    doRun(): Promise<void>;
    doSetSpeed(): Promise<void>;
    evaluateConditional(script: ScriptShape): Promise<WebDriverExecutorCondEvalResult>;
    elementIsLocated(locator: string, ..._fallbacks: (undefined | [string, string][])[]): Promise<WebElementShape | null>;
    withCancel<T extends () => Promise<any>>(poller: T): () => Promise<any>;
    waitForElement(locator: string, ...fallbacks: (undefined | [string, string][])[]): Promise<WebElementShape>;
    isElementEditable(element: WebElementShape): Promise<boolean>;
    waitForElementVisible(locator: string, timeout: number, ...fallbacks: (undefined | [string, string][])[]): Promise<webdriver.WebElement>;
    waitForText(locator: string, text: string, fallback?: [string, string][]): Promise<void>;
}
export {};
//# sourceMappingURL=webdriver.d.ts.map