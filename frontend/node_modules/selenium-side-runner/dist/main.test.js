"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const side_runtime_1 = require("@seleniumhq/side-runtime");
const jest_each_1 = __importDefault(require("jest-each"));
const fs_1 = __importDefault(require("fs"));
const glob_1 = require("glob");
const winston_1 = require("winston");
const connect_1 = __importDefault(require("./connect"));
const run_1 = __importDefault(require("./run"));
const metadata = require('../package.json');
process.title = metadata.name;
// Capture and show unhandled exceptions
process.on('unhandledRejection', function handleWarning(reason) {
    console.log('[PROCESS] Unhandled Promise Rejection');
    console.log('- - - - - - - - - - - - - - - - - - -');
    console.log(reason);
    console.log('- -');
});
process.on('uncaughtException', (error) => {
    console.error('Unhandled Error', error);
});
const configuration = JSON.parse(process.env.SE_CONFIGURATION);
if (configuration.retries > 0) {
    jest.retryTimes(configuration.retries);
}
// Jest timeout should be really far back, otherwise it will impede people
// When working right, we should close shop and detonate on our own much sooner
jest.setTimeout(configuration.jestTimeout);
const logger = (0, winston_1.createLogger)({
    level: configuration.debug ? 'debug' : 'info',
    transports: [
        new winston_1.transports.Console({
            format: winston_1.format.combine(winston_1.format.colorize(), winston_1.format.simple()),
        }),
    ],
});
const projectTitle = 'Running project $name';
const suiteTitle = 'Running suite $name';
const testTitle = 'Running test $name';
const allMatchingProjects = [
    ...configuration.projects.reduce((projects, project) => {
        (0, glob_1.globSync)(project).forEach((p) => {
            projects.add(p);
        });
        return projects;
    }, new Set()),
].map((p) => {
    const project = JSON.parse(fs_1.default.readFileSync(p, 'utf8'));
    project.path = p;
    return project;
});
if (!allMatchingProjects.length) {
    throw new Error('No matching projects found, supplied filepaths: ' +
        configuration.projects.join(', '));
}
const projects = allMatchingProjects.filter((p) => {
    const projectIsFound = Boolean(p);
    if (projectIsFound) {
        const hasSuites = p.suites.filter((suite) => suite.tests.length && new RegExp(configuration.filter).test(suite.name)).length;
        if (hasSuites) {
            return true;
        }
        const hasTests = p.tests.filter((test) => new RegExp(configuration.filter).test(test.name)).length;
        if (hasTests) {
            return true;
        }
    }
    return false;
});
if (!projects.length) {
    throw new Error('No matching suites or tests found for filter in any projects, supplied filter: ' +
        configuration.filter);
}
const factoryParams = {
    configuration,
    logger: logger,
};
const getTestByID = (project) => (testID) => project.tests.find((t) => t.id === testID);
const runner = (0, run_1.default)(factoryParams);
if (configuration.debugConnectionMode) {
    test('Testing driver connection', async () => {
        await (0, connect_1.default)(configuration);
    });
}
else {
    let plugins;
    (0, jest_each_1.default)(projects).describe(projectTitle, (project) => {
        try {
            const pluginPaths = (0, side_runtime_1.correctPluginPaths)(project.path, project?.plugins ?? []);
            const runHook = (hookName) => async () => {
                if (!plugins) {
                    plugins = await (0, side_runtime_1.loadPlugins)(pluginPaths);
                }
                await Promise.all(plugins.map(async (plugin) => {
                    const hook = plugin.hooks?.[hookName];
                    if (hook) {
                        await hook({ ...factoryParams, project });
                    }
                }));
            };
            beforeAll(runHook('onBeforePlayAll'));
            afterAll(runHook('onAfterPlayAll'));
            const suites = project.suites.filter((suite) => suite.tests.length &&
                new RegExp(configuration.filter).test(suite.name));
            if (suites.length) {
                (0, jest_each_1.default)(suites).describe(suiteTitle, (suite) => {
                    const isParallel = suite.parallel;
                    const suiteVariables = new side_runtime_1.Variables();
                    const tests = suite.tests.map(getTestByID(project));
                    const testExecutor = (0, jest_each_1.default)(tests);
                    const testMethod = isParallel
                        ? testExecutor.test.concurrent
                        : testExecutor.test;
                    const persistedDriver = suite.persistSession
                        ? runner.getDriverSync()
                        : undefined;
                    testMethod(testTitle, async (test) => {
                        await runner.run(project, test, suite.persistSession ? suiteVariables : new side_runtime_1.Variables(), await (persistedDriver || Promise.resolve(undefined)));
                    });
                });
            }
            else {
                console.info(`
          Project ${project.name} doesn't have any suites matching filter ${configuration.filter},
          attempting to iterate all tests in project
        `);
                const tests = project.tests.filter((test) => new RegExp(configuration.filter).test(test.name));
                if (!tests.length) {
                    throw new Error(`No suites or tests found in project ${project.name} matching filter ${configuration.filter}, unable to test!`);
                }
                const testExecutor = (0, jest_each_1.default)(tests);
                testExecutor.test(testTitle, async (test) => {
                    await runner.run(project, test, new side_runtime_1.Variables());
                });
            }
        }
        catch (e) {
            console.warn('Failed to run project ' + project.name);
            console.error(e);
        }
    });
}
//# sourceMappingURL=main.test.js.map