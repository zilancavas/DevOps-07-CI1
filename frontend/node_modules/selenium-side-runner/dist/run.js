"use strict";
// Licensed to the Software Freedom Conservancy (SFC) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The SFC licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const side_runtime_1 = require("@seleniumhq/side-runtime");
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
const buildRun = ({ configuration, logger }) => ({
    getDriverSync: () => {
        const executor = new side_runtime_1.WebDriverExecutor({
            capabilities: JSON.parse(JSON.stringify(configuration.capabilities)),
            server: configuration.server,
        });
        return executor.getDriverSync({
            debug: configuration.debugConnectionMode,
            logger,
        });
    },
    run: async (project, test, variables = new side_runtime_1.Variables(), persistedDriver) => {
        logger.info(`Running test ${test.name}`);
        const pluginPaths = (0, side_runtime_1.correctPluginPaths)(project.path, project?.plugins ?? []);
        const plugins = await (0, side_runtime_1.loadPlugins)(pluginPaths);
        const customCommands = (0, side_runtime_1.getCustomCommands)(plugins);
        const executor = new side_runtime_1.WebDriverExecutor({
            capabilities: JSON.parse(JSON.stringify(configuration.capabilities)),
            customCommands,
            driver: persistedDriver,
            hooks: {
                onBeforePlay: async () => {
                    await Promise.all(plugins.map((plugin) => {
                        const onBeforePlay = plugin.hooks?.onBeforePlay;
                        if (onBeforePlay) {
                            return onBeforePlay({ driver: executor });
                        }
                    }));
                },
            },
            implicitWait: configuration.timeout,
            server: configuration.server,
        });
        await playbackUntilComplete();
        function playbackUntilComplete() {
            // eslint-disable-next-line no-async-promise-executor
            return new Promise(async (resolve, reject) => {
                const playback = new side_runtime_1.Playback({
                    baseUrl: configuration.baseUrl || project.url,
                    executor,
                    getTestByName: (name) => project.tests.find((t) => t.name === name),
                    logger,
                    variables,
                });
                const onComplete = async (failure) => {
                    // I know this feature is over aggressive for a tool to be deprecated
                    // but I can't figure out whats going wrong at {{paid work}} and I
                    // need this so just please don't ask me to expand on it because I
                    // don't want to own screenshotting in tool tbh. That is perfect for
                    // plugins.
                    if (failure && configuration.screenshotFailureDirectory) {
                        try {
                            const crashScreen = await executor.driver.takeScreenshot();
                            await promises_1.default.writeFile(path_1.default.join(configuration.screenshotFailureDirectory, `${test.name}_${Date.now()}.png`), crashScreen, 'base64');
                        }
                        catch (e) {
                            console.log('Failed to take screenshot', e);
                        }
                    }
                    await playback.cleanup(Boolean(persistedDriver));
                    if (failure) {
                        return reject(failure);
                    }
                    else {
                        return resolve(null);
                    }
                };
                const EE = playback['event-emitter'];
                EE.addListener(side_runtime_1.PlaybackEvents.PLAYBACK_STATE_CHANGED, ({ state }) => {
                    logger.debug(`Playing state changed ${state} for test ${test.name}`);
                    switch (state) {
                        case 'aborted':
                        case 'errored':
                        case 'failed':
                        case 'finished':
                        case 'paused':
                        case 'stopped':
                            logger.info(`Finished test ${test.name} ${state === 'finished' ? 'Success' : 'Failure'}`);
                            if (state === 'finished') {
                                return onComplete(null);
                            }
                            logger.debug('Last command:', playback['state'].lastSentCommandState?.command);
                            return onComplete(playback['state'].lastSentCommandState?.error ||
                                new Error('Unknown error'));
                    }
                    return;
                });
                EE.addListener(side_runtime_1.PlaybackEvents.COMMAND_STATE_CHANGED, ({ command, state, }) => {
                    const cmd = command;
                    const niceString = [cmd.command, cmd.target, cmd.value]
                        .filter((v) => !!v)
                        .join('|');
                    logger.debug(`${state} ${niceString}`);
                });
                try {
                    await playback.play(test, {
                        startingCommandIndex: 0,
                    });
                }
                catch (e) {
                    await playback.cleanup(Boolean(persistedDriver));
                    return reject(e);
                }
            });
        }
    },
});
exports.default = buildRun;
//# sourceMappingURL=run.js.map